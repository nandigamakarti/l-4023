import { Message } from '@/contexts/MessageContext';

/**
 * Generates meeting notes from a collection of messages
 * @param messages Array of messages to generate notes from
 * @param channelName Name of the channel or thread
 * @returns Formatted meeting notes as a string
 */
export const generateMeetingNotes = (messages: Message[], channelName: string): string => {
  // Skip if no messages
  if (!messages || messages.length === 0) {
    return 'No messages found to generate meeting notes.';
  }

  // Get the date range
  const timestamps = messages.map(msg => msg.timestamp);
  const startDate = new Date(Math.min(...timestamps.map(t => t.getTime())));
  const endDate = new Date(Math.max(...timestamps.map(t => t.getTime())));
  
  // Format dates
  const formatDate = (date: Date) => {
    return date.toLocaleString('en-US', {
      year: 'numeric', 
      month: 'short', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Get unique participants
  const participants = Array.from(new Set(messages.map(msg => msg.username))).join(', ');
  
  // Generate notes header
  let notes = `# Meeting Notes: ${channelName}\n\n`;
  notes += `**Date:** ${formatDate(startDate)} - ${formatDate(endDate)}\n`;
  notes += `**Participants:** ${participants}\n\n`;
  
  // Add summary section
  notes += `## Summary\n\n`;
  notes += `This meeting covered discussions in the ${channelName} channel.\n\n`;
  
  // Add key points section
  notes += `## Key Points\n\n`;
  
  // Group messages by user and create bullet points
  const userMessages: Record<string, string[]> = {};
  
  messages.forEach(msg => {
    if (!userMessages[msg.username]) {
      userMessages[msg.username] = [];
    }
    userMessages[msg.username].push(msg.content);
  });
  
  // Add user contributions
  Object.entries(userMessages).forEach(([username, contents]) => {
    notes += `### ${username}\n`;
    contents.forEach(content => {
      notes += `- ${content}\n`;
    });
    notes += '\n';
  });
  
  // Add action items section (placeholder - in a real app this would use AI to extract action items)
  notes += `## Action Items\n\n`;
  notes += `- Follow up on discussion points\n`;
  notes += `- Schedule next meeting\n\n`;
  
  // Add conclusion
  notes += `## Next Steps\n\n`;
  notes += `Review these notes and continue the discussion in the ${channelName} channel.\n\n`;
  
  notes += `---\n`;
  notes += `Generated by SlackAI on ${new Date().toLocaleString()}\n`;
  
  return notes;
};

/**
 * Shows meeting notes in a popup dialog
 * @param messages Array of messages to generate notes from
 * @param channelName Name of the channel or thread
 * @param onShowNotes Callback to show the notes in a popup
 */
export const showMeetingNotesPopup = (
  messages: Message[], 
  channelName: string,
  onShowNotes: (notes: string, title: string) => void
): void => {
  const notes = generateMeetingNotes(messages, channelName);
  const title = `AI Meeting Notes - ${channelName}`;
  onShowNotes(notes, title);
};

/**
 * Downloads meeting notes as a text file
 * @param messages Array of messages to generate notes from
 * @param channelName Name of the channel or thread
 */
export const downloadMeetingNotes = (messages: Message[], channelName: string): void => {
  const notes = generateMeetingNotes(messages, channelName);
  
  // Create a safe filename from the channel name
  const safeChannelName = channelName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `${safeChannelName}_meeting_notes_${timestamp}.txt`;
  
  // Create a blob and download link
  const blob = new Blob([notes], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  
  // Clean up
  setTimeout(() => {
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, 100);
};
